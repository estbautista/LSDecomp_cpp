{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"data_processing/","text":"p.function{ color:#357ab7; background:#e0e8f3; border-top:4px solid #5897cf; padding:0.3em 0.3em 0.3em 0.3em; margin-bottom:0em; font-weight: bold; } Data Processing # This chapter describes function to process data into float lien and mapping structure. The data processing functions are declared in the header file data_processing.hpp . Linkstream types are declared in the header file linkstream_types.hpp . Linkstream types # Prefix Type time_id int node int weigth double edge std::pair<node,node> weighted_graph std::vector< std::pair<edge,weigth> > graph std::vector<edge> time_edgelist std::map< time_id, weigthed_graph > node_set std::set<node> map_edge std::map<edge, int> map_node std::map<node, int> adjacency_list std::map< node, std::vector<node> > graph_set std::vector<graph> Class float_lien This class contain informations relative to float lien. It can be used to load a float lien from a file (see read_link_stream ). Data members : - time_graph ( time_edgelist ) : map where each time refers to a list(graph) of pairs with an edge and its weigth Initialization Functions # float_lien * float_lien_alloc ( ) This function allocates memory for an object of class float_lien. void float_lien_delete (float_lien* FL) This function releases allocated memory of the float_lien class object. Functions # int read_link_stream (std::string edgelist_path, float_lien *float_lien_to_fill, char delimiter = ' , ') This function read the file located at edgelist_path and load information into float_lien_to_fill . You can add a fourth column to specify the weigth of each edge otherwise it will be considered as one. You can change the delimiter between columns (default = ' , '). The text format has to be : nodeA, nodeB, timeX nodeC, nodeD, timeU ...\u2003\u2003,\u2003\u2003...\u2003\u2003,\u2003\u2003... nodeY, nodeZ, timeV int weigthedGraph_to_Graph (weigthed_graph * wg, graph *g) This function fills g ( graph ) with edges in wg ( weighted_graph ). Example # //example.cpp #include \"lib/data_processing.hpp\" int main(int argc, char **argv){ /* Initialization */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); read_link_stream(path,fl); /* Your code */ int print_limit = 100; for (time_edgelist::const_iterator t_g = fl->begin(); t_g != fl->end(); ++t_g) { int cpt = 1; std::cout << \"Time = \" << t_g->first << \" :\\n\"; for(weigthed_graph::const_iterator we = t_g->second.begin(); we != t_g->second.end(); ++we) { std::cout << \"(\" << we->first.first << \",\" << we->first.second << \"):\" << we->second << \" \"; if (cpt % 5 == 0) std::cout << std::endl; if (cpt % print_limit == 0) break; cpt++; } if (cpt % 5 != 1) std::cout << std::endl; } /* Release memory */ float_lien_delete(fl); return 0; } Compile with : g++ ... Run with : ./example relative_path/file_linkstream.txt","title":"Data Processing"},{"location":"data_processing/#data_processing","text":"This chapter describes function to process data into float lien and mapping structure. The data processing functions are declared in the header file data_processing.hpp . Linkstream types are declared in the header file linkstream_types.hpp .","title":"Data Processing"},{"location":"data_processing/#linkstream_types","text":"Prefix Type time_id int node int weigth double edge std::pair<node,node> weighted_graph std::vector< std::pair<edge,weigth> > graph std::vector<edge> time_edgelist std::map< time_id, weigthed_graph > node_set std::set<node> map_edge std::map<edge, int> map_node std::map<node, int> adjacency_list std::map< node, std::vector<node> > graph_set std::vector<graph> Class float_lien This class contain informations relative to float lien. It can be used to load a float lien from a file (see read_link_stream ). Data members : - time_graph ( time_edgelist ) : map where each time refers to a list(graph) of pairs with an edge and its weigth","title":"Linkstream types"},{"location":"data_processing/#initialization_functions","text":"float_lien * float_lien_alloc ( ) This function allocates memory for an object of class float_lien. void float_lien_delete (float_lien* FL) This function releases allocated memory of the float_lien class object.","title":"Initialization Functions"},{"location":"data_processing/#functions","text":"int read_link_stream (std::string edgelist_path, float_lien *float_lien_to_fill, char delimiter = ' , ') This function read the file located at edgelist_path and load information into float_lien_to_fill . You can add a fourth column to specify the weigth of each edge otherwise it will be considered as one. You can change the delimiter between columns (default = ' , '). The text format has to be : nodeA, nodeB, timeX nodeC, nodeD, timeU ...\u2003\u2003,\u2003\u2003...\u2003\u2003,\u2003\u2003... nodeY, nodeZ, timeV int weigthedGraph_to_Graph (weigthed_graph * wg, graph *g) This function fills g ( graph ) with edges in wg ( weighted_graph ).","title":"Functions"},{"location":"data_processing/#example","text":"//example.cpp #include \"lib/data_processing.hpp\" int main(int argc, char **argv){ /* Initialization */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); read_link_stream(path,fl); /* Your code */ int print_limit = 100; for (time_edgelist::const_iterator t_g = fl->begin(); t_g != fl->end(); ++t_g) { int cpt = 1; std::cout << \"Time = \" << t_g->first << \" :\\n\"; for(weigthed_graph::const_iterator we = t_g->second.begin(); we != t_g->second.end(); ++we) { std::cout << \"(\" << we->first.first << \",\" << we->first.second << \"):\" << we->second << \" \"; if (cpt % 5 == 0) std::cout << std::endl; if (cpt % print_limit == 0) break; cpt++; } if (cpt % 5 != 1) std::cout << std::endl; } /* Release memory */ float_lien_delete(fl); return 0; } Compile with : g++ ... Run with : ./example relative_path/file_linkstream.txt","title":"Example"},{"location":"decomposition/","text":"p.function{ color:#357ab7; background:#e0e8f3; border-top:4px solid #5897cf; padding:0.3em 0.3em 0.3em 0.3em; margin-bottom:0em; font-weight: bold; } Decomposition # This chapter describes functions for performing Haar wavelet transform. Some of these type structure are based on gsl or Armadillo library. The wavelet functions are declared in the header file decomposition.h . The mapping functions are declared in the header files mapping_BFS.h and mapping_SVD.h . Organization # This module is internally divided into 3 submodules : - decomposition.h for wavelet decomposition with different mapping - mapping_BFS.h to run B readth- Fi rst S earch mapping - mapping_SVD.h to run S ingular V alue D ecomposition mapping Initialization # Transform workspace # Type sp_workspace This structure contains a sparse matrix to hold intermediate results the transform. sp_workspace * sp_workspace_graph_alloc (size_t size1, size_t size2 = 1) This function allocates memory for structure variable of sp_workspace. void sp_workspace_delete (sp_workspace * work) This function releases allocated memory of sp_workspace structure variable. Decomposition Result Matrix # The wavelet decomposition will segment data into 2 parts : A ccuracy and D ifference. To hold these results, we use a dense matrix A for the A ccuracy part and a sparse matrix for the D ifference part. The first dimension of these matrices depend on the size of the data and number of level you run. The second dimension is the number of graph in your graph sequence (1 for a simple graph). size_t size1A (size_t n, uint level) This function returns the size of the first dimension for a dense matrix A to hold result from level wavelet transform of size n. (use for allocation) size_t size1D (size_t n, uint level) This function returns the size of the first dimension for a sparse matrix D to hold result from level wavelet transform of size n. (use for allocation) gsl_matrix * matrixA_alloc (size_t dim1, size_t dim2, uint level) gsl_matrix * matrixA_alloc (map_edge *m, uint level, size_t n_graphs = 1) gsl_matrix * matrixA_alloc (graph *g, uint level) These functions allocate memory for dense matrix A. gsl_spmatrix * matrixD_alloc (size_t dim1, size_t dim2, uint level) gsl_spmatrix * matrixD_alloc (map_edge *m, uint level, size_t n_graphs = 1) gsl_spmatrix * matrixD_alloc (graph *g, uint level) These functions allocate memory for sparse matrix D. void matrixA_delete (gsl_matrix *A) This function releases allocated memory of dense matrix A. void matrixD_delete (gsl_spmatrix *D) This function releases allocated memory of sparse matrix D. Mapping # There is map to store unique if of each edge ( map_edge ) and other for each node ( map_node ). BFS # This mapping follows B readth- Fi rst S earch order of a graph to give id to each edges and hold the result in a map_edge . map_edge * map_edge_alloc ( ) This function allocates memory for map_edge structure variable. void map_edge_delete (map_edge *m) This function releases allocated memory of map_edge structure variable. int mapping_BFS (graph *g, map_edge *m) This function fills m ( map_edge ) by processing BFS algorithm on g ( graph ). SVD # This mapping computes the adjacency matrix of a graph and does S ingular V alue D ecomposition recursively on it to relabelized each node. Then we can use the function fct_edge_graph who returns an unique id ( |VxV| ) for each edge by giving the label of the twice nodes. map_node * map_node_alloc ( ) This function allocates memory for map_node structure variable. void map_node_delete (map_node *m) This function releases allocated memory of map_node structure variable. int mapping_SVD (graph *g, map_node *m) This function fills m ( map_node ) by processing recursively SVD on the adjacency matrix of g ( graph ). int fct_map_edge (int i, int j) This mapping function returns an unique edge id (|VxV|) by giving 2 nodes labels (i->j). Transform graph # int max_lvl_decomposition (graph *g) int max_lvl_decomposition (map_edge *m) These functions return the maximum level of wavelet decomposition you can compute. int wavelet_transform_by_level (const gsl_wavelet * w, gsl_spmatrix *data, size_t n, gsl_wavelet_direction dir, sp_workspace * work, uint nb_level = 1, uint current_lvl = 0) This function computes nb_level haar wavelet transform from current_lvl in the direction dir . A sparse matrix of data and a sparse worspace work with a size n has to be provided. To perform wavelet transform, gsl_wavelet w has be to initialized as gsl_wavelet_haar and k = 2. int decomposition_BFS (graph *g, map_edge *m, uint level, gsl_matrix *A, gsl_matrix *D) int decomposition_SVD (graph *g, map_node *m, uint level, gsl_matrix *A, gsl_matrix *D) These functions compute decomposition of graph with haar wavelet transform, following the indicated mapping ( BFS or SVD ) and fill matrix A (resp. D) with the accuracy (resp. difference) part. Memory for matrices A et D has to be allocated with appropriate sizes (see functions : size1A , size1D ). Transform linkstream # int aggregate_link_stream (float_lien *fl, graph *g) This function fills g ( graph ) as the aggregation of graphs for all time in fl ( float_lien ). Memory has to be allocated for g . (Use for graph decomposition) int graph_sequence_decomposition_BFS (graph_set *gs, map_edge *m, uint level, gsl_matrix *A, gsl_spmatrix *D) This function computes the decomposition of graph sequence with haar wavelet transform, following BFS mapping m and fill matrix A (resp. D) with the accuracy (resp. difference) part. Memory for matrices A et D has to be allocated with size2 equal to number of graph in the sequence and size1 with the appropriate value (see functions : size1A , size1D ). Example # Wavelet Decomposition with SVD mapping : // example.cpp #include \"lib/data_processing.hpp\" #include \"lib/decomposition.h\" int main(int argc, char **argv) { /* Initialisation */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); map_node *m = map_node_alloc(); graph *g = new graph(); gsl_matrix *A; gsl_spmatrix *D; std::cout << \"===== Data processing =====\\n\"; read_link_stream(path, fl); std::cout << \"===== End Data processing =====\\n\"; /* Aggregation of graphs for all time in fl */ aggregate_link_stream(fl, g); std::cout << \"===== MAPPING =====\\n\"; mapping_SVD(g, m); std::cout << \"===== End Mapping =====\\n\"; std::cout << \"===== Decomposition =====\\n\"; uint level = max_lvl_decomposition(g); A = matrixA_alloc(g, level); D = matrixD_alloc(g, level); decomposition_SVD(g, m, level, A, D); std::cout << \"===== FIN Decomposition =====\\n\"; /* Release memory */ matrixA_delete(A); matrixD_delete(D); float_lien_delete(fl); map_node_delet(m); delete g; return 0; } Compile with : g++ ... Run with : ./example relative_path/file_linkstream.txt","title":"Decomposition"},{"location":"decomposition/#decomposition","text":"This chapter describes functions for performing Haar wavelet transform. Some of these type structure are based on gsl or Armadillo library. The wavelet functions are declared in the header file decomposition.h . The mapping functions are declared in the header files mapping_BFS.h and mapping_SVD.h .","title":"Decomposition"},{"location":"decomposition/#organization","text":"This module is internally divided into 3 submodules : - decomposition.h for wavelet decomposition with different mapping - mapping_BFS.h to run B readth- Fi rst S earch mapping - mapping_SVD.h to run S ingular V alue D ecomposition mapping","title":"Organization"},{"location":"decomposition/#initialization","text":"","title":"Initialization"},{"location":"decomposition/#transform_workspace","text":"Type sp_workspace This structure contains a sparse matrix to hold intermediate results the transform. sp_workspace * sp_workspace_graph_alloc (size_t size1, size_t size2 = 1) This function allocates memory for structure variable of sp_workspace. void sp_workspace_delete (sp_workspace * work) This function releases allocated memory of sp_workspace structure variable.","title":"Transform workspace"},{"location":"decomposition/#decomposition_result_matrix","text":"The wavelet decomposition will segment data into 2 parts : A ccuracy and D ifference. To hold these results, we use a dense matrix A for the A ccuracy part and a sparse matrix for the D ifference part. The first dimension of these matrices depend on the size of the data and number of level you run. The second dimension is the number of graph in your graph sequence (1 for a simple graph). size_t size1A (size_t n, uint level) This function returns the size of the first dimension for a dense matrix A to hold result from level wavelet transform of size n. (use for allocation) size_t size1D (size_t n, uint level) This function returns the size of the first dimension for a sparse matrix D to hold result from level wavelet transform of size n. (use for allocation) gsl_matrix * matrixA_alloc (size_t dim1, size_t dim2, uint level) gsl_matrix * matrixA_alloc (map_edge *m, uint level, size_t n_graphs = 1) gsl_matrix * matrixA_alloc (graph *g, uint level) These functions allocate memory for dense matrix A. gsl_spmatrix * matrixD_alloc (size_t dim1, size_t dim2, uint level) gsl_spmatrix * matrixD_alloc (map_edge *m, uint level, size_t n_graphs = 1) gsl_spmatrix * matrixD_alloc (graph *g, uint level) These functions allocate memory for sparse matrix D. void matrixA_delete (gsl_matrix *A) This function releases allocated memory of dense matrix A. void matrixD_delete (gsl_spmatrix *D) This function releases allocated memory of sparse matrix D.","title":"Decomposition Result Matrix"},{"location":"decomposition/#mapping","text":"There is map to store unique if of each edge ( map_edge ) and other for each node ( map_node ).","title":"Mapping"},{"location":"decomposition/#bfs","text":"This mapping follows B readth- Fi rst S earch order of a graph to give id to each edges and hold the result in a map_edge . map_edge * map_edge_alloc ( ) This function allocates memory for map_edge structure variable. void map_edge_delete (map_edge *m) This function releases allocated memory of map_edge structure variable. int mapping_BFS (graph *g, map_edge *m) This function fills m ( map_edge ) by processing BFS algorithm on g ( graph ).","title":"BFS"},{"location":"decomposition/#svd","text":"This mapping computes the adjacency matrix of a graph and does S ingular V alue D ecomposition recursively on it to relabelized each node. Then we can use the function fct_edge_graph who returns an unique id ( |VxV| ) for each edge by giving the label of the twice nodes. map_node * map_node_alloc ( ) This function allocates memory for map_node structure variable. void map_node_delete (map_node *m) This function releases allocated memory of map_node structure variable. int mapping_SVD (graph *g, map_node *m) This function fills m ( map_node ) by processing recursively SVD on the adjacency matrix of g ( graph ). int fct_map_edge (int i, int j) This mapping function returns an unique edge id (|VxV|) by giving 2 nodes labels (i->j).","title":"SVD"},{"location":"decomposition/#transform_graph","text":"int max_lvl_decomposition (graph *g) int max_lvl_decomposition (map_edge *m) These functions return the maximum level of wavelet decomposition you can compute. int wavelet_transform_by_level (const gsl_wavelet * w, gsl_spmatrix *data, size_t n, gsl_wavelet_direction dir, sp_workspace * work, uint nb_level = 1, uint current_lvl = 0) This function computes nb_level haar wavelet transform from current_lvl in the direction dir . A sparse matrix of data and a sparse worspace work with a size n has to be provided. To perform wavelet transform, gsl_wavelet w has be to initialized as gsl_wavelet_haar and k = 2. int decomposition_BFS (graph *g, map_edge *m, uint level, gsl_matrix *A, gsl_matrix *D) int decomposition_SVD (graph *g, map_node *m, uint level, gsl_matrix *A, gsl_matrix *D) These functions compute decomposition of graph with haar wavelet transform, following the indicated mapping ( BFS or SVD ) and fill matrix A (resp. D) with the accuracy (resp. difference) part. Memory for matrices A et D has to be allocated with appropriate sizes (see functions : size1A , size1D ).","title":"Transform graph"},{"location":"decomposition/#transform_linkstream","text":"int aggregate_link_stream (float_lien *fl, graph *g) This function fills g ( graph ) as the aggregation of graphs for all time in fl ( float_lien ). Memory has to be allocated for g . (Use for graph decomposition) int graph_sequence_decomposition_BFS (graph_set *gs, map_edge *m, uint level, gsl_matrix *A, gsl_spmatrix *D) This function computes the decomposition of graph sequence with haar wavelet transform, following BFS mapping m and fill matrix A (resp. D) with the accuracy (resp. difference) part. Memory for matrices A et D has to be allocated with size2 equal to number of graph in the sequence and size1 with the appropriate value (see functions : size1A , size1D ).","title":"Transform linkstream"},{"location":"decomposition/#example","text":"Wavelet Decomposition with SVD mapping : // example.cpp #include \"lib/data_processing.hpp\" #include \"lib/decomposition.h\" int main(int argc, char **argv) { /* Initialisation */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); map_node *m = map_node_alloc(); graph *g = new graph(); gsl_matrix *A; gsl_spmatrix *D; std::cout << \"===== Data processing =====\\n\"; read_link_stream(path, fl); std::cout << \"===== End Data processing =====\\n\"; /* Aggregation of graphs for all time in fl */ aggregate_link_stream(fl, g); std::cout << \"===== MAPPING =====\\n\"; mapping_SVD(g, m); std::cout << \"===== End Mapping =====\\n\"; std::cout << \"===== Decomposition =====\\n\"; uint level = max_lvl_decomposition(g); A = matrixA_alloc(g, level); D = matrixD_alloc(g, level); decomposition_SVD(g, m, level, A, D); std::cout << \"===== FIN Decomposition =====\\n\"; /* Release memory */ matrixA_delete(A); matrixD_delete(D); float_lien_delete(fl); map_node_delet(m); delete g; return 0; } Compile with : g++ ... Run with : ./example relative_path/file_linkstream.txt","title":"Example"},{"location":"examples/","text":"Examples # This chapter shows examples of program to used the library. Data processing # //example.cpp #include \"lib/data_processing.hpp\" int main(int argc, char **argv){ /* Initialization */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); read_link_stream(path,fl); /* Your code */ int print_limit = 100; for (time_edgelist::const_iterator t_g = fl->begin(); t_g != fl->end(); ++t_g) { int cpt = 1; std::cout << \"Time = \" << t_g->first << \" :\\n\"; for(weigthed_graph::const_iterator we = t_g->second.begin(); we != t_g->second.end(); ++we) { std::cout << \"(\" << we->first.first << \",\" << we->first.second << \"):\" << we->second << \" \"; if (cpt % 5 == 0) std::cout << std::endl; if (cpt % print_limit == 0) break; cpt++; } if (cpt % 5 != 1) std::cout << std::endl; } /* Release memory */ float_lien_delete(fl); return 0; } Decomposition # // example.cpp #include \"lib/data_processing.hpp\" #include \"lib/decomposition.h\" int main(int argc, char **argv) { /* Initialisation */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); map_node *m = map_node_alloc(); graph *g = new graph(); gsl_matrix *A; gsl_spmatrix *D; std::cout << \"===== Data processing =====\\n\"; read_link_stream(path, fl); std::cout << \"===== End Data processing =====\\n\"; /* Aggregation of graphs for all time in fl */ aggregate_link_stream(fl, g); std::cout << \"===== MAPPING =====\\n\"; mapping_SVD(g, m); std::cout << \"===== End Mapping =====\\n\"; std::cout << \"===== Decomposition =====\\n\"; uint level = max_lvl_decomposition(g); A = matrixA_alloc(g, level); D = matrixD_alloc(g, level); decomposition_SVD(g, m, level, A, D); std::cout << \"===== FIN Decomposition =====\\n\"; /* Release memory */ matrixA_delete(A); matrixD_delete(D); float_lien_delete(fl); map_node_delet(m); delete g; return 0; }","title":"Examples"},{"location":"examples/#examples","text":"This chapter shows examples of program to used the library.","title":"Examples"},{"location":"examples/#data_processing","text":"//example.cpp #include \"lib/data_processing.hpp\" int main(int argc, char **argv){ /* Initialization */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); read_link_stream(path,fl); /* Your code */ int print_limit = 100; for (time_edgelist::const_iterator t_g = fl->begin(); t_g != fl->end(); ++t_g) { int cpt = 1; std::cout << \"Time = \" << t_g->first << \" :\\n\"; for(weigthed_graph::const_iterator we = t_g->second.begin(); we != t_g->second.end(); ++we) { std::cout << \"(\" << we->first.first << \",\" << we->first.second << \"):\" << we->second << \" \"; if (cpt % 5 == 0) std::cout << std::endl; if (cpt % print_limit == 0) break; cpt++; } if (cpt % 5 != 1) std::cout << std::endl; } /* Release memory */ float_lien_delete(fl); return 0; }","title":"Data processing"},{"location":"examples/#decomposition","text":"// example.cpp #include \"lib/data_processing.hpp\" #include \"lib/decomposition.h\" int main(int argc, char **argv) { /* Initialisation */ (void)(argc); /* avoid unused parameter warning */ std::string path = argv[1]; float_lien *fl = float_lien_alloc(); map_node *m = map_node_alloc(); graph *g = new graph(); gsl_matrix *A; gsl_spmatrix *D; std::cout << \"===== Data processing =====\\n\"; read_link_stream(path, fl); std::cout << \"===== End Data processing =====\\n\"; /* Aggregation of graphs for all time in fl */ aggregate_link_stream(fl, g); std::cout << \"===== MAPPING =====\\n\"; mapping_SVD(g, m); std::cout << \"===== End Mapping =====\\n\"; std::cout << \"===== Decomposition =====\\n\"; uint level = max_lvl_decomposition(g); A = matrixA_alloc(g, level); D = matrixD_alloc(g, level); decomposition_SVD(g, m, level, A, D); std::cout << \"===== FIN Decomposition =====\\n\"; /* Release memory */ matrixA_delete(A); matrixD_delete(D); float_lien_delete(fl); map_node_delet(m); delete g; return 0; }","title":"Decomposition"},{"location":"home/","text":"Introduction # Link stream, also known as float lien, is a set of edge over different time. This library contains routines to manipulate such structure by computing decomposition. Abstract # Esteban Bautista (2022) : A link stream is a set of triplets (t, u, v) modeling interactions over time and their effective analysis is key for numerous applications. They are traditionally studied via signal processing and graph theory approaches, which allow to study their dynamical and structural properties. However, current techniques do not allow to accurately reveal the frequency-structure patterns contained in them. To overcome this limitation, this work introduces a novel decomposition for link streams. Our decomposition analyses the time dimension via traditional signal dictionaries, like Fourier or wavelets, and the structural dimension via a new decomposition for graphs that we tailored to analyze sequences of graphs.","title":"Home"},{"location":"home/#introduction","text":"Link stream, also known as float lien, is a set of edge over different time. This library contains routines to manipulate such structure by computing decomposition.","title":"Introduction"},{"location":"home/#abstract","text":"Esteban Bautista (2022) : A link stream is a set of triplets (t, u, v) modeling interactions over time and their effective analysis is key for numerous applications. They are traditionally studied via signal processing and graph theory approaches, which allow to study their dynamical and structural properties. However, current techniques do not allow to accurately reveal the frequency-structure patterns contained in them. To overcome this limitation, this work introduces a novel decomposition for link streams. Our decomposition analyses the time dimension via traditional signal dictionaries, like Fourier or wavelets, and the structural dimension via a new decomposition for graphs that we tailored to analyze sequences of graphs.","title":"Abstract"},{"location":"install/","text":"Installation # Download # Download GSL library and Armadillo library Error gsl # To avoid : $> error while loading shared libraries: libgsl.so.27: cannot open shared object file: No such file or directory Try : sudo ldconfig See : https://stackoverflow.com/questions/22222666/error-while-loading-shared-libraries-libgsl-so-0-cannot-open-shared-object-fil","title":"Install"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#download","text":"Download GSL library and Armadillo library","title":"Download"},{"location":"install/#error_gsl","text":"To avoid : $> error while loading shared libraries: libgsl.so.27: cannot open shared object file: No such file or directory Try : sudo ldconfig See : https://stackoverflow.com/questions/22222666/error-while-loading-shared-libraries-libgsl-so-0-cannot-open-shared-object-fil","title":"Error gsl"},{"location":"licences/","text":"Licences # As a project using a derivative work of the GSL library and Armadillo library binaries, it must comply with the following GNU General Public License and Apache license : Copyright (C) 2022 Bastien Guillemare This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Licences"},{"location":"licences/#licences","text":"As a project using a derivative work of the GSL library and Armadillo library binaries, it must comply with the following GNU General Public License and Apache license : Copyright (C) 2022 Bastien Guillemare This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Licences"}]}